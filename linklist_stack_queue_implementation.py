# -*- coding: utf-8 -*-
"""Linklist_Stack_Queue Implementation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WJXcX1tPepZN7jTlHT0UMVCzK-95Z3ar

#**Link List**

## **Single Link List Implementation**
"""

class Node:
  def __init__(self,item=None,next=None):
    self.item=item
    self.next=next

class Single_link_list:
  def __init__(self,start=None):
    self.start=start
  # Check list is empty
  def is_Empty(self):
    return self.start==None

  def insert_at_start(self,data):
    n=Node(data,self.start)
    self.start=n

  def insert_at_last(self,data):
    n=Node(data,None)
    temp=self.start
    if not self.is_Empty():
      while temp.next is not None:
        temp=temp.next
      temp.next=n
    else:
      n=self.start

  def search(self,data):
    temp=self.start
    while temp is not None:
      if temp.item==data:
        return temp
      else:
        temp=next.temp
    return None

  def insert_after(self,temp,data):
    if temp is not None:
      n=Node(data,temp.next)
      temp.next=n

  def print_list(self):
    temp=self.start
    while temp is not None:
      print(temp.item,end=' ')
      temp=temp.next

  def delete_first(self):
    if self.start is not None:
      self.start=self.start.next

  def delete_last(self):
    if self.start is None:
      pass
    elif self.start.next is None:
      self.start=None
    else:
      temp=self.start
      while temp.next.next is not None:
        temp=temp.next
      temp.next=None
  def delete_item(self,data):
    if self.start is None:
      pass
    elif self.start.next is None:
      if self.start.item==data:
        self.start=None
    else:
      temp=self.start
      if temp.item==data:
        self.start=temp.next
      else:
        while temp.next is not None:
          if temp.next.item==data:
            temp.next=temp.next.next
            break
          temp=temp.next
  def __iter__(self):
    return SllIterator(self.start)



class SllIterator:
  def __init__(self,start):
    self.current=start
  def __iter__(self):
    return self
  def __next__(self):
    if not self.current:
      raise StopIteration
    data=self.current.item
    self.current=self.current.next
    return data



mylist=Single_link_list()
mylist.insert_at_start(10)
mylist.insert_at_last(20)
mylist.insert_after(mylist.search(10),30)
mylist.print_list()
print()
for i in mylist:
  print(i)
print()
mylist.delete_last()
mylist.delete_first()
mylist.print_list()
print()

"""## **Doubly Link List Implementation**"""

class Node:
    def __init__(self,prev=None,item=None,next=None):
        self.prev=prev
        self.item=item
        self.next=next

class DLL:
    def __init__(self,start=None):
        self.start=start
    def is_empty(self):
        return self.start==None
    def insert_at_start(self,data):
        n=Node(None,data,self.start)
        if not self.is_empty():
            self.start.prev=n
        else:
            self.start=n

    def insert_at_last(self,data):
        temp=self.start
        if temp!=None:
            while temp.next !=None:
                temp=temp.next
        n=Node(temp,data,None)
        if temp==None:
            self.start=n
        else:
            temp.next=n

    def search_item(self,data):
        temp=self.start
        while temp!=None:
            if temp.item==data:
                return temp
            temp=temp.next
        return None
    def insert_after(self,temp,data):
        if temp is not None:
            n=Node(temp,data,temp.next)
            if temp.next is not None:
                temp.next.prev=n
            temp.nexta=n
    def print_list(self):
        temp=self.start
        while temp is not None:
            print(temp.item,end=' ')
            temp=temp.next

    def delete_first(self):
        if self.start is not None:
            self.start=self.start.next
            if self.start is not None:
                self.start.prev=None

    def delete_last(self):
        if self.start==None:
            pass
        elif self.start.next ==None:
            self.start=None
        else:
            temp=self.start
            while temp.next is not None:
                temp=temp.next
            temp.prev.next=None
    def delete_item(self,data):
        if self.start is None:
            pass
        else:
            temp=self.start
            while temp is not None:
                if temp.item==data:
                    if temp.next is not None:
                        temp.next.prev=temp.prev
                    if temp.prev is not None:
                        temp.prev.next=temp.next
                    else:
                        self.start=temp.next
                    break
                temp=temp.next
    def __iter__(self):
        return DLLIterator(self.start)
class  DLLIterator:
    def __init__(self,start):
        self.current=start
    def __iter__(self):
        return self
    def __next__(self):
        if not self.current:
            raise StopIteration
        data=self.current.item
        self.current=self.current.next
        return data

mylist=DLL()
mylist.insert_at_start(10)
mylist.insert_at_last(20)
mylist.insert_after(mylist.search_item(10),15)
for x in mylist:
    print(x,end=" ")
print()

"""### **Circular Link List Implementation**"""

class Node:
    def __init__(self, item=None,next=None):
        self.item=item
        self.next=next
class CLL:
    def __init__(self,last=None):
        self.last=last

    def is_empty(self):
        return self.last==None

    def insert_at_start(self,data):
        n=Node(data)
        if self.is_empty():
            n.next=n
            self.last=n
        else:
            n.next=self.last.next
            self.last.next=n

    def insert_at_last(self,data):
        n=Node(data)
        if self.is_empty():
            n.next=n
            self.last=n
        else:
            n.next=self.last.next
            self.last.next=n
            self.last=n

    def search(self,data):
        if self.is_empty():
            return None
        temp=self.last.next
        while temp!=self.last:
            if temp.item==data:
                return temp
            temp=temp.next
        if temp.item==data:
            return temp
        return None
    def insert_after(self,temp,data):
        if temp is not None:
            n=Node(data,temp.next)
            temp.next=n
            if temp==self.last:
                self.last=n

    def print_list(self):
        if not self.is_empty():
            temp=self.last.next
            while temp!=self.last:
                print(temp.item,end=' ')
                temp=temp.next
            print(temp.item)

    def delete_first(self):
        if not self.is_empty():
            if self.last.next==self.last:
                self.last=None
            else:
                self.last.next=self.last.next.next

    def delete_last(self):
        if not self.is_empty():
            if self.last.next==self.last:
                self.last=None
            else:
                temp=self.last.next
                while temp.next!=self.last:
                    temp=temp.next
                temp.next=self.last.next
                self.last=temp
    def delete_item(self,data):
        if not self.is_empty():
            if self.last.next==self.last:
                if self.last.item==data:
                    self.last=None
            else:
                if self.last.next.item==data:
                    self.delete_first()
                else:
                    temp=self.last.next
                    while temp.next!=self.last:
                        if temp.next==self.last:
                            if self.last.item==data:
                                self.delete_last()
                            break
                        if temp.next.item==data:
                            temp.next=temp.next.next
                            break
                        temp=temp.next
    def __iter__(self):
        if self.last==None:
            return CLLIterator(None)
        else:
            return CLLIterator(self.last.next)


class CLLIterator:
    def __init__(self,start):
        self.current=start
        self.start=start
        self.count=0
    def __iter__(self):
        return self
    def __next__(self):
        if self.current==None:
            raise StopIteration
        if self.current==self.start and self.count==1:
            raise StopIteration
        else:
            self.count=1
        data=self.current.item
        self.current=self.current.next

        return data


cll=CLL()
cll.insert_at_start(10)
cll.insert_at_start(20)
cll.insert_at_start(30)
cll.insert_at_last(40)
cll.insert_at_last(50)
cll.insert_after(cll.search(10),100)
cll.print_list()
cll.delete_first()
cll.delete_last()
cll.print_list()
cll.delete_item(10)
cll.print_list()
print("Print Through Iterator object ")
for i in cll:
    print(i)

"""### **Circular Doubaly Link List Implementation**"""

class Node:
    def __init__(self,item=None,prev=None,next=None):
        self.prev=prev
        self.item=item
        self.next=next

class CDLL:
    def __init__(self,start=None):
        self.start=start

    def is_empty(self):
        return self.start==None

    def insert_at_start(self,data):
        n=Node(data)
        if not self.is_empty():
            n.prev=self.start.prev
            n.next=self.start
            self.strat.prev.next=n
            self.strat.prev=n
        else:
            n.next=n
            n.prev=n
        self.start=n
    def insert_at_last(self,data):
        n=Node(data)
        if self.is_empty():
            n.next=n
            n.prev=n
            self.start=n
        else:
            n.prev=self.start.prev
            n.next=self.start
            n.prev.next=n
            self.start.prev=n
    def search(self,data):
        temp=self.start
        if temp==None:
            return None
        if temp.item==data:
            return temp
        else:
            temp=temp.next
        while temp is not self.start:
            if temp.item==data:
                return temp
            temp=temp.next
        return temp

    def insert_after(self,temp,data):
        if temp is not None:
            n=Node(data)
            n.next=temp.next
            n.prev=temp.prev
            temp.next.prev=n
            temp.next=n
    def print_list(self):
        temp=self.start
        if temp is not None:
            print(temp.item,end=' ')
            temp=temp.next
            while temp is not self.start:
                print(temp.item,end=' ')
                temp=temp.next
    def delete_first(self):
        if self.start is not None:
            if self.start.next==self.start:
                self.start=None
            else:
                self.start.prev.next=self.start.next
                self.satrt.next.prev=self.prev
                self.start=self.start.next
    def delete_last(self):
        if self.start is not None:
            if self.start.next==self.start:
                self.start=None
            else:
                self.start.prev.prev.next=self.start
                self.start.prev=self.start.prev.prev
    def delete_item(self,data):
        if self.start is not None:
            temp=self.start
            if temp.item==data:
                self.delete_first()
            else:
                temp=temp.next
                while temp is not self.start:
                    if temp.item==data:
                        temp.next.prev=temp.prev
                        temp.prev.next=temp.next
                    temp=temp.next

    def __iter__(self):
        return CDLLIterator(self.start)
class CDLLIterator:
    def __init__(self,start):
        self.current=start
        self.count=0
        self.start=start
    def __iter__(self):
        return self
    def __next__(self):
        if self.current is None:
            raise StopIteration
        if self.current==self.start and self.count==1:
            raise StopIteration
        else:
            self.count=1
        data=self.current.item
        self.current=self.current.next
        return data

cdll=CDLL()
cdll.insert_at_start(10)
cdll.insert_at_last(20)
cdll.insert_at_last(30)
cdll.insert_after(cdll.search(30),35)
cdll.print_list()
print()
for x in cdll:
    print(x)

"""### **Find the middle element of the LinkedList**"""

# TC : O(n+n//2)
# SC:O(1)
def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:
  temp=head
  count=0
  while temp!=None:
      count+=1
      temp=temp.next
  mid_node=count//2 +1
  temp=head
  while temp!=None:
      mid_node-=1
      if mid_node==0:
          break
      temp=temp.next
  return temp

"""### **Tortoise Hare Algo**"""

# TortoiseHare Method
# TC : O(n//2)
# SC:O(1)
def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:
  slow=head
  fast=head
  while fast!=None and fast.next!=None:
      slow=slow.next
      fast=fast.next.next
  return slow

"""### **Reverse a LinkedList**"""

# TC : O(2n)
# SC:O(n)
def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
  stack=[]
  temp=head
  while temp!=None:
      stack.append(temp.val)
      temp=temp.next
  temp=head
  while temp!=None:
      temp.val=stack[-1]
      stack.pop()
      temp=temp.next
  return head

# TC : O(n)
# SC:O(1)
def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
  temp=head
  prev=None
  while temp!=None:
      first=temp.next
      temp.next=prev
      prev=temp
      temp=first
  return prev

def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head==None or head.next==None:
            return head
        new_head=self.reverseList(head.next)
        front=head.next
        front.next=head
        head.next=None
        return new_head

"""### **Detect a loop or cycle in LinkedList**"""

# TC : O(n* log2(n))
# SC:O(n)
def hasCycle(self, head: Optional[ListNode]) -> bool:
  d={}
  temp=head
  while temp!=None:
      if temp not in d:
          d[temp]=1
      else:
          return True
      temp=temp.next
  return False

# TC : O(n)
# SC:O(1)
def hasCycle(self, head: Optional[ListNode]) -> bool:
  slow=head
  fast=head
  while fast!=None and fast.next!=None:
  slow=slow.next
  fast=fast.next.next
  if slow==fast:
      return True
  return False

"""### **Find the starting point of the Loop**"""

# TC : O(n* log2(n))
# SC:O(n)
def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
  d={}
  temp=head
  while temp!=None:
      if temp not in d:
          d[temp]=1
      else:
          return temp
      temp=temp.next
  return

# TC : O(n)
# SC:O(1)
def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
  slow=head
  fast=head
  while fast!=None and fast.next!=None:
      slow=slow.next
      fast=fast.next.next
      if slow==fast:
          slow=head
          while slow!=fast:
              slow=slow.next
              fast=fast.next
          return slow
  return None

"""### **Check if LL is palindrome or not**"""

# TC : O(n)+O(n)
# SC:O(n)
def isPalindrome(self, head: Optional[ListNode]) -> bool:
  stack=[]
  temp=head
  while temp!=None:
      stack.append(temp.val)
      temp=temp.next
  temp=head
  while temp!=None:
      if temp.val!=stack[-1]:
          return False
      temp=temp.next
      stack.pop()
  return True

"""### **Odd Even Linked List**"""

# TC : O(n/2)+O(n/2)+O(n)
# SC:O(n)
def oddEvenList(self, head: Optional[ListNode]) -> Optional[ListNode]:
  temp=head
  l=[]
  if temp==None:
      return head
  while temp!=None and temp.next!=None:
      l.append(temp.val)
      temp=temp.next.next
  if temp:
      l.append(temp.val)


  temp=head.next
  while temp!=None and temp.next!=None:
      l.append(temp.val)
      temp=temp.next.next
  if temp:
      l.append(temp.val)

  temp=head
  i=0
  while temp!=None:
      temp.val=l[i]
      i+=1
      temp=temp.next
  return head

# TC :O(n)
# SC:O(1)
def oddEvenList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        odd=head
        even=head.next
        even_head=head.next
        if head==None or head.next==None:
            return head
        while even!=None and even.next!=None:
            odd.next=odd.next.next
            even.next=even.next.next
            odd=odd.next
            even=even.next.next
        odd.next=even_head
        return head

"""### **Remove Nth node from the back of the LL**"""

# TC :O(2n)
# SC:O(1)
def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
  temp=head
  count=0
  while temp!=None:
      count+=1
      temp=temp.next
  if count==n:
      new_head=head.next
      return new_head
  temp=head
  res=count-n
  while temp!=None:
      res-=1
      if res==0:
          break
      temp=temp.next
  temp.next=temp.next.next
  return head

# TC :O(2n)
# SC:O(1)
def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
  fast=head
  for i in range(n):
      fast=fast.next
  slow=head
  if fast==None:
      return head.next
  while fast.next!=None:
      slow=slow.next
      fast=fast.next
  slow.next=slow.next.next
  return head

"""### **Delete the middle node of the LinkedList**"""

# TC :O(n)+O(n/2)
# SC:O(1)
def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:
  temp=head
  count=0
  if head==None:
      return head
  if head.next==None:
      return head.next
  while temp!=None:
      count+=1
      temp=temp.next
  n=(count//2)-1
  temp=head
  for i in range(n):
      temp=temp.next
  temp.next=temp.next.next
  return head

# TC :O(n)
# SC:O(1)
# Find the middle element by slow but we reqire one before middle so we skip a single step of slow value in TortoiseHare algo
 def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:
    slow=head
    fast=head

    if head==None:
        return None
    if head.next==None:
        return head.next
    fast=fast.next.next
    while fast!=None and  fast.next !=None:
        slow=slow.next
        fast=fast.next.next
    slow.next=slow.next.next
    return head

"""### **Sort a Linked List**"""

# TC :O(n)+O(nlogn)+O(n)
# SC:O(n)
def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
  l=[]
  temp=head
  if temp==None:
      return None
  while temp!=None:
      l.append(temp.val)
      temp=temp.next
  temp=head
  l.sort()
  i=0
  while temp!=None:
      temp.val=l[i]
      i+=1
      temp=temp.next
  return head

"""### **Add 2 numbers in LinkedList**"""

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        temp1=l1
        num1=[]
        while temp1!=None:
            num1.append(temp1.val)
            temp1=temp1.next
        num2=[]
        temp2=l2
        while temp2!=None:
            num2.append(temp2.val)
            temp2=temp2.next
        num1.reverse()
        num2.reverse()
        inta = int("".join(str(x) for x in num1))
        intb = int("".join(str(x) for x in num2))
        num=inta+intb
        head=curr=ListNode()
        if num==0:
            return head
        while num!=0:
            curr.next=ListNode(num%10)
            num=num//10
            curr=curr.next
        return head.next

"""### **Find the intersection point of Y LinkedList**"""

class Solution:
  def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:
      temp=headA
      d={}
      while temp!=None:
          if temp not in d:
              d[temp]=1
          temp=temp.next
      temp=headB
      while temp!=None:
          if temp in d:
              return temp
          temp=temp.next
      return None

"""### **Rotate a LinkedList**"""

def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:
  if head==None or head.next==None:
      return head
  length=1
  tail=head
  while tail.next!=None:
      length+=1
      tail=tail.next
  k=k%length
  if k==0:
      return head

  temp=head
  n=length-k
  while temp!=None:
      if n==1:
          newlast=temp
      temp=temp.next
      n-=1
  tail.next=head
  head=newlast.next
  newlast.next=None
  return head

arr=[1,2,3,4,5]
k=2
def rotate(arr,k):
  length=len(arr)
  k=k%length
  if k==0:
    return arr

nums = [1,2,3,4,5,6,7]
k=3
length=len(nums)
n=length-k
l=[]
for i in range(n,length):
    l.append(nums[i])
for j in range(n):
    l.append(nums[j])
print(l)

"""#**Stack Data Structure**"""

class Stack:
    def __init__(self):
        self.items=[]
    def is_empty(self):
        return len(self.items)==0
    def push(self,data):
        self.items.append(data)
    def pop(self):
        if not self.is_empty():
            return self.items.pop()
        else:
            raise IndexError("Stack is empty")
    def peek(self):
        if not self.is_empty():
            return self.items[-1]
        else:
            raise IndexError("Stack is empty")
    def size(self):
        return len(self.items)
s1=Stack()
s1.push(1)
s1.push(2)
s1.push(3)
print("peak element", s1.peek())

"""### **Implement stack by inherate the list class**"""

class Stack(list):
    def is_empty(self):
        return len(self)==0
    def push(self,data):
        self.append(data)
    def pop(self):
        if not self.is_empty():
            return super().pop()
        else:
            raise IndexError('stack is empty')
    def peek(self):
        if not self.is_empty():
            return self[-1]
        else:
            raise IndexError('stack is empty')
    def size(self):
        return len(self)
    def insert(self,index,data):
        raise AttributeError('No attribute insert in stack')
s1=Stack()
s1.push(10)
s1.push(20)
print('top value is ',s1.peek())

"""### **Implementation of Stack using linked list concept**"""

class Node:
  def __init__(self,item=None,next=None):
    self.item=item
    self.next=next
class stack:
  def __init__(self):
    self.top=None
    self.item_count=0
  def is_empty(self):
    return self.top==None
  def push(self,data):
    n=Node(data,self.top)
    self.top=n
    self.item_count+=1
  def pop(self):
    if not self.is_empty():
      data=self.top.item
      self.top=self.top.next
      self.item_count-=1
      return data
    else:
      raise IndexError("Stack is empty")
  def peek(self):
    if not self.is_empty():
      return self.top.item
    else:
      raise IndexError("Stack is empty")
  def size(self):
    return self.item_count

s1=stack()
s1.push(10)
s1.push(20)
s1.push(30)
s1.push(40)
print('size of stack is ',s1.size())
s1.peek()
s1.pop()
print('After pop')
print('size of stack is ',s1.size())
s1.peek()

class MyStack:

    def __init__(self):
        self.data=[]


    def push(self, x: int) -> None:
        self.data.append(x)
        return self.data


    def pop(self) -> int:
        return self.data.pop()


    def top(self) -> int:
        return self.data[-1]


    def empty(self) -> bool:
        return len(self.data)



# Your MyStack object will be instantiated and called as such:
#["MyStack","push","push","top","pop","empty"]
obj = MyStack()
obj.push("MyStack")
obj.push("push")
param_2 = obj.pop()
param_3 = obj.top()
param_4 = obj.empty()
print(param_2)
print(param_3)
print(param_4)

"""### **Convert infix to postfix**"""

# TC: O(2n)
# SC: O(n)

def priority(s):
    if s == '^':
        return 3
    elif s in ('*', '/'):
        return 2
    elif s in ('+', '-'):
        return 1
    else:
        return 0


def infix_to_postfix(s):
  i=0
  stack=[]
  ans=''
  n=len(s)
  while(i<n):
    if s[i].isdigit() or s[i].isalpha():
    #if (s[i]>= 'A' and s[i]<='Z') or (s[i]>= 'a' and s[i]<='z') or (s[i]>= '0' and s[i]<='9'):
      ans+=s[i]
    elif s[i]=='(':
      stack.append(s[i])
    elif s[i]==')':
      while(len(stack)!=0 and stack[-1]!='('):
        ans+=stack[-1]
        stack.pop()
      stack.pop()
    else:
      while (len(stack)!=0 and priority(s[i])<=priority(stack[-1])):
        ans+=stack[-1]
        stack.pop()
      stack.append(s[i])
    i+=1
  while len(stack)!=0:
    ans+=stack[-1]
    stack.pop()
  return ans

s='a+b*(c^d-c)'
infix_to_postfix(s)

"""### **Convert Infix to prefix**"""

# TC: O(3n)
# SC: O(n)

def priority(s):
    if s == '^':
        return 3
    elif s in ('*', '/'):
        return 2
    elif s in ('+', '-'):
        return 1
    else:
        return 0
def infix_to_prefix(s):
  stack=[]
  s=s[::-1]
  res=''
  for i in s:
    if i==')':
      res+='('
    elif i=='(':
      res+=')'
    else:
      res+=i
  i=0
  ans=''
  n=len(res)
  while(i<n):
    if res[i].isdigit() or res[i].isalpha():
    #if (s[i]>= 'A' and s[i]<='Z') or (s[i]>= 'a' and s[i]<='z') or (s[i]>= '0' and s[i]<='9'):
      ans+=res[i]
    elif res[i]=='(':
      stack.append(res[i])

    elif res[i]==')':
      while(len(stack)!=0 and stack[-1]!='('):
        ans+=stack[-1]
        stack.pop()
      stack.pop()
    else:
      if res[i]=='^':
        while (len(stack)!=0 and priority(res[i])<=priority(stack[-1])):
          ans+=stack[-1]
          stack.pop()
      else:
        while (len(stack)!=0 and priority(res[i])<priority(stack[-1])):
          ans+=stack[-1]
          stack.pop()
      stack.append(s[i])
    i+=1
  while len(stack)!=0:
    ans+=stack[-1]
    stack.pop()
  return ans[::-1]

s="(A+B)*C-D+F"
infix_to_postfix(s)

s="(A+B)*C-D+F"
s=s[::-1]
print(s)
ans=''
for i in s:
  if i==')':
    ans+='('
  elif i=='(':
    ans+=')'
  else:
    ans+=i
print(ans)

"""### **Postfix to infix**"""

# TC: O(2n)
# SC: O(n)
def postfix_to_infix(s):
  stack=[]
  i=0
  temp=''
  while i<len(s):
    if s[i].isdigit() or s[i].isalpha():
      stack.append(s[i])
    else:
      t1=stack.pop()
      t2=stack.pop()
      temp='('+t2+s[i]+t1+')'
      stack.append(temp)
    i+=1
  return stack[-1]
s="abcd^c-*+"
postfix_to_infix(s)

# 'a+b*(c^d-c)'

"""### **Prefix to infix**"""

# TC: O(2n)
# SC: O(n)
def pretfix_to_infix(s):
  stack=[]
  i=len(s)-1
  temp=''
  while i>=0:
    if s[i].isdigit() or s[i].isalpha():
      stack.append(s[i])
    else:
      t1=stack.pop()
      t2=stack.pop()
      temp='('+t1+s[i]+t2+')'
      stack.append(temp)
    i-=1
  return stack[-1]
s="+-*+ABCDF"
pretfix_to_infix(s)
# "(A+B)*C-D+F"

"""### **Convert Postfix to prefix**"""

# TC: O(n)
# SC: O(n)
def pretfix_to_infix(s):
  stack=[]
  i=0
  temp=''
  while i<len(s):
    if s[i].isdigit() or s[i].isalpha():
      stack.append(s[i])
    else:
      t1=stack.pop()
      t2=stack.pop()
      temp=s[i]+t2+t1
      stack.append(temp)
    i+=1
  return stack[-1]
s="ab-de+f*/"
pretfix_to_infix(s)

"""### **Convert Prefix to Postfix**"""

# TC: O(2n)
# SC: O(n)
def pretfix_to_infix(s):
  stack=[]
  i=len(s)-1
  temp=''
  while i>=0:
    if s[i].isdigit() or s[i].isalpha():
      stack.append(s[i])
    else:
      t1=stack.pop()
      t2=stack.pop()
      temp=t1+t2+s[i]
      stack.append(temp)
    i-=1
  return stack[-1]
s="/-ab*+def"
pretfix_to_infix(s)
# "(A+B)*C-D+F"

"""### **Next Greater Element or Monotonic Stack**"""

# TC: O(n**2)
# SC: O(n)
def monotonic(arr):
  ans=[-1]*len(arr)
  for i in range(len(arr)):
    for j in range(i+1,len(arr)):
      if arr[j]>=arr[i]:
        ans[i]=arr[j]
        break
      else:
        ans[i]=-1
  return ans
arr=[6,0,8,1,3]
monotonic(arr)

# TC: O(2n)
# SC: O(n)
def monotonic(arr):
  n=len(arr)
  stack=[]
  nge=[-1]*len(arr)
  for i in range(n-1,-1,-1):
    while len(stack)!=0 and stack[-1]<=arr[i]:
      stack.pop()
    if len(stack)==0:
      nge[i]=-1
    else:
      nge[i]=stack[-1]
    stack.append(arr[i])
  return nge
arr=[6,0,8,1,3]
monotonic(arr)

def nextGreaterElement(nums1,nums2):
  n1=len(nums1)
  n2=len(nums2)
  ans=[]
  for i in range(n1):
    for j in range(n2):
      if nums1[i]==nums2[j]:
        for k in range(j,n2):
          if nums1[i]<nums2[k]:
            ans.append(nums2[k])
            break
        else:
          ans.append(-1)
  return ans
nums1 = [2,4]
nums2 = [1,2,3,4]

nextGreaterElement(nums1,nums2)

"""### **Next Greater Element - II**"""

# TC: O(n**2)
# SC: O(n)
def monotonic(arr):
  ans=[-1]*len(arr)
  for i in range(len(arr)):
    for j in range(i+1,len(arr)):
      if arr[j]>arr[i]:
        ans[i]=arr[j]
        break
    else:
      for k in range(0,i):
        if arr[k]>arr[i]:
          ans[i]=arr[k]
          break
  return ans
arr=[1,2,1]
monotonic(arr)

# Use concept of circuler list
# TC : O(n^2)
# SC: O(n)
def monotonic(arr):
  n=len(arr)
  ans=[-1]*n
  for i in range(n):
    for j in range(i+1,i+n):
      idx=j%n
      if arr[idx]>arr[i]:
        ans[i]=arr[idx]
        break
  return ans
arr=[1,2,1]
monotonic(arr)

# TC: O(4n)
# SC: O(2n)
def monotonic(nums):
  n=len(nums)
  nge=[-1]*n
  st=[]
  for i in range(2*n-1,-1,-1):
    while len(st)!=0 and st[-1]<=nums[i%n]:
      st.pop()
    if i<n:
      if len(st)==0:
        nge[i]=-1
      else:
        nge[i]=st[-1]
    st.append(nums[i%n])
  return nge
arr=[1,2,1]
monotonic(arr)

"""### **Previous Smaller Element**


"""

# TC: O(n^2)
# SC: O(n)
def pre_smaller(arr):
  n=len(arr)
  ans=[-1]*n
  for i in range(n):
    for j in range(i-1,-1,-1):
      if arr[i]>arr[j]:
        ans[i]=arr[j]
        break
  return ans
arr=[4,5,2,10,8]
pre_smaller(arr)

# TC: O(n)
# SC: O(n)
def pre_smaller(arr):
  n=len(arr)
  st=[]
  pse=[0]*n
  for i in range(n):
    while len(st)!=0 and st[-1]>arr[i]:
      st.pop()
    if len(st)==0:
      pse[i]=-1
    else:
      pse[i]=st[-1]
    st.append(arr[i])
  return pse
arr=[4,5,2,10,8]
pre_smaller(arr)

"""### **Previous gratter Element**"""

def previous_gratter_element(arr):
  n=len(arr)
  ans=[-1]*n
  for i in range(n):
    for j in range(i-1,-1,-1):
      if arr[i]<arr[j]:
        ans[i]=arr[j]
        break
  return ans
arr=[4,5,2,10,8]
previous_gratter_element(arr)

def previous_gratter_element(arr):
  n=len(arr)
  ans=[-1]*n
  stack=[]
  for i in range(n):
    if len(stack)!=0 and stack[-1]>=arr[i]:
      ans[i]=stack[-1]
    elif len(stack)!=0 and stack[-1]<arr[i]:
      stack.append(arr[i])
    stack.append(arr[i])
  return ans
arr=[4,5,2,10,8]
previous_gratter_element(arr)

l=[]
l.append((1,2))
print(l[-1][1])
for i in range(len(l)):
  print(l[i][0])

"""### **Next Smaller Element**"""

# TC: O(2n)
# SC: O(n)
def monotonic(arr):
  n=len(arr)
  stack=[]
  nge=[0]*len(arr)
  for i in range(n-1,-1,-1):
    while len(stack)!=0 and stack[-1]>=arr[i]:
      stack.pop()
    if len(stack)==0:
      nge[i]=-1
    else:
      nge[i]=stack[-1]
    stack.append(arr[i])
  return nge
arr=[6,0,8,1,3]
monotonic(arr)

"""### **Trapping Rainwater**"""

def trap(height=[]):
  n=len(height)
  total=0
  for i in range(n-1):
    #print(i)
    left_high=max(height[0:i+1])
    right_high=max(height[i+1:n+1])
    #print(left_high,right_high)
    if height[i]<left_high and height[i]<right_high:
      total+=min(left_high,right_high)-height[i]
  return total
height = [0,1,0,2,1,0,1,3,2,1,2,1]
#height = [4,2,0,3,2,5]
trap(height)

# TC: O(3n)
# SC: O(2n)
def trap(height=[]):
  n=len(height)
  total=0
  pre_max=[0]*n
  pre_max[0]=height[0]
  for i in range(1,n):
      pre_max[i]=max(pre_max[i-1],height[i])

  suf_max=[0]*n
  suf_max[n-1]=height[n-1]
  for i in range(n-2,-1,-1):
      suf_max[i]=max(suf_max[i+1],height[i])

  for i in range(n):
    #print(i)
    left_high=pre_max[i]
    right_high=suf_max[i]
    #print(left_high,right_high)
    if height[i]<left_high and height[i]<right_high:
      total+=min(left_high,right_high)-height[i]
  return total
height = [0,1,0,2,1,0,1,3,2,1,2,1]
height = [4,2,0,3,2,5]
trap(height)

# TC: O(n)
# SC: O(1)
def trap(arr):
  lmax=rmax=total=0
  l=0
  r=len(arr)-1
  while l<r:
    if arr[l]<=arr[r]:
      if lmax>arr[l]:
        total+=lmax-arr[l]
      else:
        lmax=arr[l]
      l+=1
    else:
      if rmax>arr[r]:
        total+=rmax-arr[r]
      else:
        rmax=arr[r]
      r-=1
  return total
height = [0,1,0,2,1,0,1,3,2,1,2,1]
#height = [4,2,0,3,2,5]
trap(height)

"""### **Sum of Subarray Minimum**"""

arr = [3,1,2,4]
def sub_min_sum(arr):
  n=len(arr)
  total=0
  ans=[]
  for i in range(n):
    for j in range(i,n):
      ans.append(arr[i:j+1])
  for l in ans:
    total+=min(l)
  return total

arr = [3,1,2,4]
sub_min_sum(arr)

arr = [3,1,2,4]
def sub_min_sum(arr):
  n=len(arr)
  total=0
  for i in range(n):
    for j in range(i,n):
      total+=min(arr[i:j+1])
  return total


arr = [3,1,2,4]
sub_min_sum(arr)

"""### **Aestroid Collisions**"""

def asteroidCollision(asteroids):
  st=[]
  n=len(asteroids)
  for i in range(n):
      if asteroids[i]>0:
          st.append(asteroids[i])
      else:
          if len(st)==0 or st[-1]<0:
              st.append(asteroids[i])
          else:
              while len(st)!=0 and abs(st[-1])<= abs(asteroids[i]):
                  st.pop()
              else:
                  if len(st)!=0 and st[-1]<0 and asteroids[i]<0:
                      st.append(asteroids[i])
                  else:
                      i+=1
  return st
asteroids =[-2,-1,2,1]
asteroidCollision(asteroids)

def asteroidCollision(asteroids):
  st=[]
  n=len(asteroids)
  for i in range(n):
      if asteroids[i]>0:
          st.append(asteroids[i])
      else:
          while len(st)!=0 and st[-1]>0 and st[-1]< abs(asteroids[i]):
            st.pop()
          if len(st)!=0 and st[-1]==abs(asteroids[i]):
            st.pop()
          else:
              if len(st)==0 or st[-1]<0:
                st.append(asteroids[i])
  return st
asteroids =[-2,-2,1,-2]
asteroidCollision(asteroids)

"""### **Sum of subarray ranges**"""

def sub_arr_sum(arr):
  n=len(arr)
  ans=[]
  for i in range(n):
    for j in range(i,n):
      ans.append(arr[i:j+1])
  sum=0
  for lst in ans:
    sum+=max(lst)-min(lst)
  return sum

arr=[4,-2,-3,4,1]
sub_arr_sum(arr)

def sub_arr_sum(arr):
  n=len(arr)
  ans=0
  for i in range(n):
    largest=arr[i]
    smallest=arr[i]
    for j in range(i+1,n):
      largest=max(largest,arr[j])
      smallest=min(smallest,arr[j])
      ans+=(largest-smallest)
  return ans
arr=[4,-2,-3,4,1]
sub_arr_sum(arr)

def removeKdigits(num,k):
  st=[]
  for i in range(len(num)):
    while len(st)!=0 and k>0 and st[-1]>num[i]:
      st.pop()
      k-=1
    st.append(num[i])
  while k>0:
    st.pop()
    k-=1
  if len(st)==0:
    return '0'
  res=''
  while st:
    res+=st[-1]
    st.pop()
  while len(res)!=0 and res[-1]=='0':
    res=res[:-1]
  ans=res[::-1]
  if len(ans)==0:
    return '0'
  return ans
num = "10"
k = 2
removeKdigits(num,k)

"""### **Sliding Window Maximum**"""

# TC: O(n-k)*k
# SC: O(n-k)
def maxSlidingWindow(nums,k):
  n=len(nums)
  ans=[]
  for i in range(n):
    if i+k==n:
      ans.append(max(nums[i:i+k]))
      break
    ans.append(max(nums[i:i+k]))

  return ans

nums = [1,3,-1,-3,5,3,6,7]
k = 3
maxSlidingWindow(nums,k)

# TC: O(n-k)*k
# SC: O(n-k)
def maxSlidingWindow(nums,k):
  n=len(nums)
  ans=[]
  for i in range(n-k+1):
    ans.append(max(nums[i:i+k]))
  return ans

nums = [1,3,-1,-3,5,3,6,7]
k = 3
maxSlidingWindow(nums,k)

# TC: O(n-k)*k
# SC: O(n-k)
def maxSlidingWindow(nums,k):
  n=len(nums)
  ans=[]
  for i in range(n-k+1):
    maxi=nums[i]
    for j in range(i+k):
      maxi=max(maxi,nums[j])
    ans.append(maxi)
  return ans
nums = [1,3,-1,-3,5,3,6,7]
k = 3
maxSlidingWindow(nums,k)

# TC: O(2n)
# SC:O(k)+ O(n-k)
def maxSlidingWindow(nums,k):
  n=len(nums)
  ans=[]
  dq=[]
  for i in range(n):
    if len(dq)!=0 and dq[0]<=i-k:
      dq.remove(dq[0])
    while len(dq)!=0 and nums[dq[-1]]<=nums[i]:
      dq.pop()
    dq.append(i)
    if i>=k-1:
      ans.append(nums[dq[0]])
  return ans
nums = [1,3,-1,-3,5,3,6,7]
k = 3
maxSlidingWindow(nums,k)





"""#**Queue Data Structure**

### **Implementation of Queue using list**
"""

class Queue:
  def __init__(self):
    self.data=[]
  def is_empty(self):
    return len(self.data)==None
  def enqueue(self,item):
    self.data.append(item)
  def dequeue(self):
    self.data=self.data[1:len(self.data)]
    # Use self.data.pop(0)
  def get_front(self):
    if not self.is_empty():
      return self.data[-1]
    else:
      raise IndexError("Queue is Empty")
  def get_rare(self):
    if not self.is_empty():
      return self.data[0]
    else:
      raise IndexError("Queue is Empty")
  def size(self):
    return len(self.data)
q=Queue()
q.enqueue(10)
q.enqueue(20)
q.enqueue(30)
print('size of queue is : ',q.size())
print('Front element is : ',q.get_front())
print('Rare element is : ',q.get_rare())
q.dequeue()
print('size of queue is : ',q.size())
print('Front element is : ',q.get_front())
print('Rare element is : ',q.get_rare())

"""### **Queue implementation using singly linked list concept**"""

class Node:
  def __init__(self,item=None,next=None):
    self.item=item
    self.next=next

class Queue:
  def __init__(self,start=None):
    self.start=start
  def is_empty(self):
    return self.start==None
  def enqueue(self,item):
    n=Node(item)
    temp=self.start
    if not self.is_empty():
      while temp.next!=None:
        temp=temp.next
      temp.next=n
    else:
      self.start=n
  def dequeue(self):
    if not self.is_empty():
        self.start=self.start.next
    else:
      return IndexError('Queue is empty')
  def get_front(self):
    temp=self.start
    if not self.is_empty():
      while temp.next!=None:
        temp=temp.next
      return temp.item
    else:
      return IndexError('Queue is empty')
  def get_rare(self):
    if not self.is_empty():
      return self.start.item
    else:
      return IndexError('Queue is empty')
  def size(self):
    cnt=0
    temp=self.start
    while temp!=None:
      cnt+=1
      temp=temp.next
    return cnt

q=Queue()
q.enqueue(10)
q.enqueue(20)
q.enqueue(30)
print(q.is_empty())
print('size of queue is : ',q.size())
print('Front element is : ',q.get_front())
print('Rare element is : ',q.get_rare())
q.dequeue()
print('size of queue is : ',q.size())
print('Front element is : ',q.get_front())
print('Rare element is : ',q.get_rare())

class Node:
  def __init__(self,item=None,next=None):
    self.item=item
    self.next=next
class Queue:
  def __init__(self,front=None,rare=None):
    self.front=front
    self.rare=rare
    self.item_count=0
  def is_empty(self):
    return self.front==None
  def enqueue(self,data):
    n=Node(data)
    if self.is_empty():
      self.front=n
    else:
      self.rare.next=n
    self.rare=n
    self.item_count+=1
  def dequeue(self):
    if self.is_empty():
      raise IndexError(" Empty Queue")
    elif self.front==self.rare:
      self.front=None
      self.rare=None
    else:
      self.front=self.front.next
    self.item_count-=1

  def get_front(self):
    if self.is_empty():
      raise IndexError(" Empty Queue")
    else:
      return self.front.item

  def get_rare(self):
    if self.is_empty():
      raise IndexError(" Empty Queue")
    else:
      return self.rare.item

  def size(self):
    return self.item_count

q=Queue()
q.enqueue(10)
q.enqueue(20)
q.enqueue(30)
print(q.is_empty())
print('size of queue is : ',q.size())
print('Front element is : ',q.get_front())
print('Rare element is : ',q.get_rare())
q.dequeue()
print('size of queue is : ',q.size())
print('Front element is : ',q.get_front())
print('Rare element is : ',q.get_rare())







"""### **Push and Pop Method**"""

s='Madhusudan'
l=[]
# Use push operation
for i in s:
  l.append(i)

# Use pop operation
rev=''
for j in range(len(l)-1,-1,-1):
  rev+=l.pop(j)
print(rev)

s='Madhusudan'
stack=[]
# Use push operation
for i in s:
  stack.append(i)

# Use pop operation
rev=''
for j in range(len(stack)):
  rev+=stack.pop()
print(rev)

"""### **isEmpty method**


"""

# Check Stack is empty is not
stack=[1]
len(stack)==0

# Check Stack is empty is not
stack=[1]
not stack

"""### **Top element of stack**"""

stack=[1,2,3,4,5,6]
print(stack[-1])









